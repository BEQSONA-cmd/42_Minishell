1. Display prompt for new commands. ✅

2. Maintain command history. ✅

3. Locate and execute the correct command using PATH or provided path. ✅

4. Use a single global variable for signal indication to avoid data structure conflicts. ✅

5. Ignore unclosed quotes and unnecessary special characters like \ or ;. ✅

6. Handle ' to prevent interpreting metacharacters within quoted sequences. ✅

7. Handle " to prevent interpreting metacharacters except $ within quoted sequences. ✅

8. Redirections:
    < redirects input. ✅?
    > redirects output. ✅?
    << reads input until a specified delimiter without updating history. ✅?
    >> redirects output in append mode. ✅?

9. Implement pipes (|) to connect command outputs to inputs of subsequent commands. ✅
    unclosed fds. ✅

10. Expand environment variables ($ followed by characters). ✅

11. Expand $? to the exit status of the most recent foreground pipeline. ✅

12. Handle ctrl-C, ctrl-D, and ctrl-\ as in bash. ✅

13. Shell builtins:
    echo -n option. ✅
    cd with relative or absolute path. ✅
    pwd with no options. ✅
    export with no options. ✅
    unset with no options. ✅
    env with no options or arguments. ✅
    exit with no options. ✅

14. Error handle:
    open minishell inside minishell. ✅
    remove currect directory from inside. ✅
    unclosed quotes " and '. ✅
    shell level after 999. ✅


Dasha:
    open quotes ✅
    put tokens into commands ✅
    make exec work with command array of structs, and check builtins work with arguments ✅
    check err (like redir to nowhere, pipe without both sides ...) ✅
    fix cmdarr for exactly THIS CASE: some cmd <>file ✅
    fix cases when $ is not first in " (ex: echo "hello $SHLVL; echo "< $SHLVL" => hello 1; < 1)✅

    separate fn split_save_divider NORM
    cut all the prinf-errors into the error function with differnt type nums
    add exit status at the end
